实现三类接口：**执行故障**、**查看故障状态与事件**、**停止故障**。方案以 **ChaosBlade Operator** 为后端，通过 **Kubernetes API** 创建/读取/删除 `ChaosBlade` CR，对应的 `kubectl` 命令也一并给出。并提供**Redis 持久化**故障名称与关联信息的实现骨架。

---

# 一、接口设计（对外 REST）

1. **执行故障**
   `POST /api/faults:execute`
   请求：传入**故障定义模板（JSON）**，它能**一对一转换为 YAML 并可 `kubectl apply`**。

* 支持两种输入：
  A) 只传 `spec`（推荐，`apiVersion/kind/metadata` 由服务补齐）；
  B) 传完整 `ChaosBlade`（`apiVersion/kind/metadata/spec`）——服务会校验与补齐必需项。
* 可选：`name`（不传则后端生成）、`labels/annotations`、`durationSec`（TTL，到点自动删除）。

响应：`{ bladeName, faultId }`。

2. **查看故障状态与事件**
   `GET /api/faults/{bladeName}/status`
   响应：`phase`、`expStatuses`（原样回传）、`events`（近N条事件），以及简要归纳。

3. **停止故障**
   `DELETE /api/faults/{bladeName}`
   响应：204；若不存在返回 404。

> 恢复/回滚：ChaosBlade 的“停止”=**删除 CR**，Operator 的 `finalizer` 会清理注入（例如 tc 规则/iptables 等）。**进程 Kill/容器 Remove** 等动作\*\*不可“反向恢复”\*\*被杀死的进程/容器，只能依赖控制器重建或重新拉起。

---

# 二、对应的 `kubectl` 命令（等价功能）

* **执行（创建）**：
  `kubectl apply -f fault.yaml`

* **查看状态**：
  `kubectl get chaosblade <bladeName> -o yaml`（看 `.status.phase` 与 `.status.expStatuses`）

* **查看事件（两种）**：

  * `kubectl describe chaosblade <bladeName>`（底部 Events）
  * `kubectl get events --all-namespaces --field-selector involvedObject.kind=ChaosBlade,involvedObject.name=<bladeName> --sort-by=.lastTimestamp`

* **停止（销毁）**：
  `kubectl delete chaosblade <bladeName>`

* **查看 Operator 日志（排障）**：
  `kubectl -n chaosblade logs deploy/chaosblade-operator`

---

# 三、系统组件与配置

## 1) 依赖（`pom.xml` 摘要）

```xml
<properties>
  <java.version>21</java.version>
  <spring-boot.version>3.5.0</spring-boot.version>
  <fabric8.client.version>6.10.0</fabric8.client.version>
</properties>

<dependencyManagement>
  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-dependencies</artifactId>
      <version>${spring-boot.version}</version>
      <type>pom</type><scope>import</scope>
    </dependency>
  </dependencies>
</dependencyManagement>

<dependencies>
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
  </dependency>

  <!-- Fabric8 Kubernetes Client -->
  <dependency>
    <groupId>io.fabric8</groupId>
    <artifactId>kubernetes-client</artifactId>
    <version>${fabric8.client.version}</version>
  </dependency>

  <!-- Redis（Lettuce） -->
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
  </dependency>

  <!-- YAML 序列化（用于 JSON->YAML 可视化/持久化） -->
  <dependency>
    <groupId>com.fasterxml.jackson.dataformat</groupId>
    <artifactId>jackson-dataformat-yaml</artifactId>
  </dependency>

  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
  </dependency>
</dependencies>
```

## 2) 应用配置（`application.yml`）

```yaml
spring:
  redis:
    host: 116.63.51.45
    port: 6379
    database: 0
    timeout: 5000ms
    lettuce:
      pool:
        max-active: 8
        max-idle: 8
        min-idle: 0

app:
  faults:
    default-ttl-seconds: 0   # 0 表示不自动删除；可按需设置
    events-limit: 50         # 查询事件最大条数
```

## 3) RBAC（部署到 K8s 时请给本应用的 SA 授权）

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: faults-api
  namespace: <your-ns>

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: faults-api-chaosblade
rules:
- apiGroups: ["chaosblade.io"]
  resources: ["chaosblades"]
  verbs: ["get","list","watch","create","patch","delete"]
- apiGroups: ["", "events.k8s.io"]
  resources: ["events"]
  verbs: ["get","list","watch"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: faults-api-chaosblade-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: faults-api-chaosblade
subjects:
- kind: ServiceAccount
  name: faults-api
  namespace: <your-ns>
```

---

# 四、后端实现骨架（可直接粘贴改造）

## 1) 基础 Bean（K8s 客户端 + 调度器）

```java
@Configuration
public class InfraConfig {
  @Bean KubernetesClient kubernetesClient() { return new DefaultKubernetesClient(); }

  @Bean ThreadPoolTaskScheduler taskScheduler() {
    var s = new ThreadPoolTaskScheduler();
    s.setPoolSize(4); s.setThreadNamePrefix("fault-ttl-"); s.initialize();
    return s;
  }
}
```

## 2) Redis 持久化（记录故障名等）

* Key 约定：

  * `faults:<bladeName>` → HASH：`faultId, bladeName, createdAt, specYaml, status, ttlSec`
  * `faults:index` → SET：所有 `bladeName`（便于检索）

```java
@Repository
public class FaultRedisRepo {
  private final StringRedisTemplate redis;
  public FaultRedisRepo(StringRedisTemplate redis) { this.redis = redis; }

  public void save(String bladeName, Map<String,String> data, long ttlSec) {
    String key = "faults:" + bladeName;
    redis.opsForHash().putAll(key, data);
    if (ttlSec > 0) redis.expire(key, Duration.ofSeconds(ttlSec));
    redis.opsForSet().add("faults:index", bladeName);
  }
  public Map<Object,Object> get(String bladeName) {
    return redis.opsForHash().entries("faults:" + bladeName);
  }
  public void delete(String bladeName) {
    redis.delete("faults:" + bladeName);
    redis.opsForSet().remove("faults:index", bladeName);
  }
}
```

## 3) ChaosBlade 通用动态客户端

```java
@Component
public class ChaosBladeApi {
  private static final CustomResourceDefinitionContext CTX =
      new CustomResourceDefinitionContext.Builder()
        .withGroup("chaosblade.io").withVersion("v1alpha1")
        .withPlural("chaosblades").withScope("Cluster").build();

  private final KubernetesClient client;
  public ChaosBladeApi(KubernetesClient client) { this.client = client; }

  public GenericKubernetesResource create(String name, Map<String,String> labels, Map<String,Object> spec) {
    var blade = new GenericKubernetesResourceBuilder()
        .withApiVersion("chaosblade.io/v1alpha1")
        .withKind("ChaosBlade")
        .withNewMetadata().withName(name).withLabels(labels).endMetadata()
        .build();
    blade.setAdditionalProperty("spec", spec);
    return client.genericKubernetesResources(CTX).resource(blade).create();
  }

  public GenericKubernetesResource get(String name) {
    return client.genericKubernetesResources(CTX).withName(name).get();
  }

  public boolean delete(String name) {
    return client.genericKubernetesResources(CTX).withName(name).delete();
  }

  @SuppressWarnings("unchecked")
  public Map<String,Object> status(GenericKubernetesResource blade) {
    if (blade == null) return Map.of();
    var s = blade.getAdditionalProperties().get("status");
    return (s instanceof Map<?,?> m) ? (Map<String,Object>) m : Map.of();
  }

  /** 读取 ChaosBlade 关联的事件（core/v1 与 events.k8s.io/v1 均尝试） */
  public List<Map<String,Object>> eventsForBlade(String bladeName, int limit) {
    // core/v1
    var list1 = client.v1().events().inAnyNamespace()
      .withField("involvedObject.kind", "ChaosBlade")
      .withField("involvedObject.name", bladeName)
      .list().getItems();
    List<Map<String,Object>> out = new ArrayList<>();
    list1.stream().limit(limit).forEach(e -> out.add(Map.of(
        "type", e.getType(), "reason", e.getReason(),
        "message", e.getMessage(), "lastTimestamp", String.valueOf(e.getLastTimestamp())
    )));
    // 可按需追加 events.k8s.io/v1
    return out;
  }
}
```

## 4) JSON →（可 `kubectl apply` 的）YAML 存档 & 统一 Spec 处理

```java
@Component
public class SpecNormalizer {
  private final ObjectMapper json = new ObjectMapper();
  private final ObjectMapper yaml = new ObjectMapper(new YAMLFactory());

  /** 入参可能是完整 CR 或仅有 spec；统一产出 {apiVersion,kind,metadata,spec} */
  @SuppressWarnings("unchecked")
  public Map<String,Object> normalize(Map<String,Object> input, String bladeName, Map<String,String> labels) {
    Map<String,Object> root = new LinkedHashMap<>(input);
    Map<String,Object> out = new LinkedHashMap<>();
    // 若只传 spec，则补齐头部
    if (!root.containsKey("apiVersion") && root.containsKey("spec")) {
      out.put("apiVersion", "chaosblade.io/v1alpha1");
      out.put("kind", "ChaosBlade");
      out.put("metadata", Map.of("name", bladeName, "labels", labels));
      out.put("spec", root.get("spec"));
      return out;
    }
    // 传了完整 CR：覆盖 metadata.name/合并 labels
    out.put("apiVersion", root.getOrDefault("apiVersion","chaosblade.io/v1alpha1"));
    out.put("kind", root.getOrDefault("kind","ChaosBlade"));

    Map<String,Object> meta = (Map<String,Object>) root.getOrDefault("metadata", new LinkedHashMap<>());
    meta.put("name", bladeName);
    Map<String,String> mergedLabels = new LinkedHashMap<>(labels);
    Object l0 = meta.get("labels");
    if (l0 instanceof Map<?,?> lm) lm.forEach((k,v) -> mergedLabels.put(String.valueOf(k), String.valueOf(v)));
    meta.put("labels", mergedLabels);
    out.put("metadata", meta);

    out.put("spec", root.get("spec"));
    return out;
  }

  public String toYaml(Map<String,Object> normalized) throws JsonProcessingException {
    return yaml.writeValueAsString(normalized);
  }
}
```

## 5) 服务层：执行/查询/停止 + TTL（自动删除）

```java
@Service
public class FaultsService {
  private final ChaosBladeApi bladeApi;
  private final FaultRedisRepo repo;
  private final ThreadPoolTaskScheduler scheduler;
  private final SpecNormalizer normalizer;
  @Value("${app.faults.events-limit:50}") int eventsLimit;

  public FaultsService(ChaosBladeApi bladeApi, FaultRedisRepo repo,
                       ThreadPoolTaskScheduler scheduler, SpecNormalizer normalizer) {
    this.bladeApi = bladeApi; this.repo = repo; this.scheduler = scheduler; this.normalizer = normalizer;
  }

  public Map<String,String> execute(Map<String,Object> faultJson, String name, Integer durationSec) {
    String faultId = UUID.randomUUID().toString().replace("-", "");
    String bladeName = (name!=null && !name.isBlank()) ? name : ("blade-" + faultId.substring(0,12));
    Map<String,String> labels = Map.of("fault-id", faultId, "owner","faults-api");

    // 归一化 CR 并创建
    Map<String,Object> normalized = normalizer.normalize(faultJson, bladeName, labels);
    @SuppressWarnings("unchecked")
    Map<String,Object> spec = (Map<String,Object>) normalized.get("spec");
    bladeApi.create(bladeName, labels, spec);

    // 保存 YAML 用于审计/复现
    String yaml = "";
    try { yaml = normalizer.toYaml(normalized); } catch (Exception ignored) {}
    long ttl = (durationSec!=null && durationSec>0) ? durationSec : 0;

    repo.save(bladeName, Map.of(
        "faultId", faultId,
        "bladeName", bladeName,
        "createdAt", Instant.now().toString(),
        "specYaml", yaml
    ), ttl);

    // TTL 到点自动删除
    if (ttl > 0) {
      scheduler.schedule(() -> { try { bladeApi.delete(bladeName); repo.delete(bladeName); } catch (Exception ignored) {} },
          Date.from(Instant.now().plusSeconds(ttl)));
    }

    return Map.of("faultId", faultId, "bladeName", bladeName);
  }

  public Map<String,Object> statusAndEvents(String bladeName) {
    var blade = bladeApi.get(bladeName);
    if (blade == null) throw new NoSuchElementException("Blade not found: " + bladeName);
    var status = bladeApi.status(blade);
    var events = bladeApi.eventsForBlade(bladeName, eventsLimit);

    // 轻量提炼
    String phase = String.valueOf(status.getOrDefault("phase","Unknown"));
    return Map.of(
        "bladeName", bladeName,
        "phase", phase,
        "status", status,
        "events", events
    );
  }

  public void stop(String bladeName) {
    boolean ok = bladeApi.delete(bladeName);
    if (!ok) throw new NoSuchElementException("Blade not found: " + bladeName);
    repo.delete(bladeName);
  }
}
```

## 6) 控制器（对外三接口）

```java
@RestController
@RequestMapping("/api/faults")
public class FaultsController {
  private final FaultsService service;
  public FaultsController(FaultsService service) { this.service = service; }

  /** 执行故障：接收完整CR或仅spec(JSON)；可选 name/durationSec */
  @PostMapping(path=":execute")
  public ResponseEntity<Map<String,String>> execute(
      @RequestParam(required = false) String name,
      @RequestParam(required = false) Integer durationSec,
      @RequestBody Map<String,Object> faultJson) {
    return ResponseEntity.ok(service.execute(faultJson, name, durationSec));
  }

  /** 查看故障状态 + 事件 */
  @GetMapping("/{bladeName}/status")
  public ResponseEntity<Map<String,Object>> status(@PathVariable String bladeName) {
    return ResponseEntity.ok(service.statusAndEvents(bladeName));
  }

  /** 停止故障（删除 CR） */
  @DeleteMapping("/{bladeName}")
  public ResponseEntity<Void> stop(@PathVariable String bladeName) {
    service.stop(bladeName);
    return ResponseEntity.noContent().build();
  }
}
```

---

# 五、请求/响应示例

## 1) 执行故障（只传 `spec` 示例：容器网络延迟）

`POST /api/faults:execute?name=pod-net-delay-001&durationSec=60`

```json
{
  "spec": {
    "experiments": [
      {
        "scope": "container",
        "target": "network",
        "action": "delay",
        "desc": "container network delay 100ms",
        "matchers": [
          {"name":"names","value":["ts-travel2-service-7896995b98-z4hqg"]},
          {"name":"namespace","value":["train-ticket"]},
          {"name":"container-names","value":["ts-travel2-service"]},
          {"name":"interface","value":["eth0"]},
          {"name":"time","value":["100"]},
          {"name":"offset","value":["10"]},
          {"name":"remote-port","value":["80"]}
        ]
      }
    ]
  }
}
```

响应：

```json
{ "faultId": "8f7a3e0c0c7e4...", "bladeName": "pod-net-delay-001" }
```

> 同一个接口也能接收**完整 CR**（带 `apiVersion/kind/metadata/spec` 的 JSON）；服务会覆盖 `metadata.name` 为你传的 `name` 参数（或后端生成）。

## 2) 查看状态与事件

`GET /api/faults/pod-net-delay-001/status`
响应（示例）：

```json
{
  "bladeName": "pod-net-delay-001",
  "phase": "Running",
  "status": { "phase":"Running", "expStatuses":[ ... ] },
  "events": [
    {"type":"Normal","reason":"Created","message":"create network delay ...","lastTimestamp":"..."},
    {"type":"Normal","reason":"Succeeded","message":"...","lastTimestamp":"..."}
  ]
}
```

## 3) 停止故障

`DELETE /api/faults/pod-net-delay-001` → 204

---

# 六、健壮性与注意事项

* **模板正确性**：本方案把“模板”交给调用方生成（你们已有模板管理）。服务只做“规范化 + 创建”。如果需要**服务器端校验**（参数必填/取值范围/安全门禁），可在 `SpecNormalizer` 前加一层 Validator（比如限制网络类必须带 `timeout` 或 `exclude-port`）。
* **TTL 与恢复**：

  * `durationSec` 到点由服务**自动 DELETE** 对应 CR；
  * 删除 CR 会触发 Operator 回收注入；进程/容器类动作不能“恢复既成事实”，但**不影响框架清理注入规则**。
* **CPU 场景**：你们当前节点是 **cgroup v2**，`container/pod cpu fullload` 在部分版本上可能失败（`cgroup deleted`），这不影响本接口层；可在上层模板侧做环境门禁或切换后端实现（Ephemeral Container + `stress-ng`）。
* **多租户/幂等**：

  * 统一使用 `bladeName` 做幂等键；
  * 为 CR 打上标签：`fault-id`、`owner` 等，便于排障与批量清理。
* **事件来源**：ChaosBlade 是 cluster-scoped 资源，事件查询用 **全局** `fieldSelector`。若个别发行版只在 `events.k8s.io/v1` 写事件，可追加那一路读取。

---

# 七、快速自测清单（建议）

1. 用示例 JSON 执行一次：`POST /api/faults:execute?name=test-net-delay&durationSec=30`
2. 立刻查状态：`GET /api/faults/test-net-delay/status`（应为 `Running`）
3. 30s 后再查：`phase` 应显示 `Destroyed/Success`（取决于执行器），CR 已被删除
4. 用 `kubectl describe chaosblade test-net-delay` 验证事件；或直接 `kubectl get events ...`
5. Redis 验证：`HGETALL faults:test-net-delay`

---

需要把上面骨架打成一个最小可运行的 demo 仓库结构（含 `Dockerfile`、`k8s Deployment`、`RBAC`、`Helm` 模板）我也可以一次性给你；或者你把一份样例“故障 JSON 模板”丢给我，我帮你校正成可用的最小模板集合。
