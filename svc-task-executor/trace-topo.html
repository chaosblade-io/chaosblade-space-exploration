<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Trace 拓扑图 - trace1.json</title>
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Microsoft YaHei", sans-serif; }
    #toolbar {
      display: flex; gap: 12px; align-items: center; padding: 10px 12px; border-bottom: 1px solid #eee; background: #fafafa; flex-wrap: wrap;
    }
    #chart { width: 100%; height: calc(100% - 60px); }
    .note { color: #666; font-size: 12px; }
    .stat { color: #333; font-size: 12px; }
    button, select, input[type="checkbox"] { cursor: pointer; }
    .sep { width: 1px; height: 18px; background: #ddd; margin: 0 6px; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
</head>
<body>
  <div id="toolbar">
    <strong>Trace 拓扑图</strong>
    <span class="sep"></span>
    <label>
      展开方向
      <select id="orientSelect">
        <option value="TB">自上而下</option>
        <option value="LR">自左至右</option>
      </select>
    </label>
    <label>
      <input type="checkbox" id="showDbEdges" checked /> 显示数据库依赖
    </label>
    <span class="sep"></span>
    <span class="stat" id="statNodes">节点: -</span>
    <span class="stat" id="statEdges">边: -</span>
    <span class="sep"></span>
    <span class="note">提示: 直接用浏览器打开可能因本地文件安全策略导致无法加载 JSON，建议在该目录下启动本地静态服务，例如: <code>python3 -m http.server 8000</code></span>
  </div>
  <div id="chart"></div>

  <script>
    const chartEl = document.getElementById('chart');
    const chart = echarts.init(chartEl);

    function by(arr, key) { return arr.map(x => x[key]); }

    function round(num, n = 2) { return Math.round(num * Math.pow(10, n)) / Math.pow(10, n); }

    function calcAvg(sum, count) { return count ? sum / count : 0; }

    function isDbSpan(span) {
      return span && span.attributes && (span.attributes['db.system'] || '').length > 0;
    }

    function dbNodeName(span) {
      const sys = span.attributes['db.system'] || 'db';
      const addr = span.attributes['server.address'] || span.attributes['net.peer.name'] || span.attributes['db.connection_string'] || '';
      // make addr concise
      let label = addr;
      try {
        if (addr.startsWith('mongodb://')) label = new URL(addr).hostname;
      } catch {}
      return `${sys}:${label || 'unknown'}`;
    }

    async function loadTrace() {
      // Try same-folder first, then repo-absolute path fallback
      const candidates = ['trace1.json', '/svc-task-executor/trace1.json'];
      for (const url of candidates) {
        try {
          const res = await fetch(url);
          if (!res.ok) continue;
          const data = await res.json();
          return data;
        } catch (e) {
          // try next
        }
      }
      throw new Error('无法加载 trace1.json');
    }

    function buildTree(spans, { includeDbEdges = true } = {}) {
      // id -> span
      const idMap = new Map();
      spans.forEach(s => idMap.set(s.id, s));

      // group children by parent_id
      const childrenMap = new Map(); // parent_id -> [childSpan]
      spans.forEach(s => {
        const pid = s.parent_id || '';
        if (!childrenMap.has(pid)) childrenMap.set(pid, []);
        childrenMap.get(pid).push(s);
      });

      // edge aggregation (service->service counts/duration)
      const svcEdgeAgg = new Map();
      function addSvcEdge(srcSvc, tgtSvc, dur) {
        if (!srcSvc || !tgtSvc) return;
        const key = srcSvc + '\t' + tgtSvc;
        if (!svcEdgeAgg.has(key)) svcEdgeAgg.set(key, { count: 0, sum: 0 });
        const e = svcEdgeAgg.get(key);
        e.count += 1;
        e.sum += (typeof dur === 'number' ? dur : 0);
      }

      // Collect DB leaves for a given span limited to the same service subtree
      function collectDbAggForService(span, svc) {
        const m = new Map(); // dbName -> {count,sum}
        if (!includeDbEdges) return m;
        (function walk(s){
          if (isDbSpan(s) && (s.service === svc)) {
            const dbn = dbNodeName(s);
            if (!m.has(dbn)) m.set(dbn, { count: 0, sum: 0 });
            const a = m.get(dbn);
            a.count += 1;
            a.sum += (typeof s.duration === 'number' ? s.duration : 0);
          }
          const kids = childrenMap.get(s.id) || [];
          kids.forEach(walk);
        })(span);
        return m;
      }



      // Build tree nodes by traversing from roots
      const roots = childrenMap.get('') || [];

      function buildNode(span) {
        const svc = span.service || 'unknown';
        const node = {
          name: svc,
          value: 1,
          itemStyle: { color: '#2f88ff' },
          children: []
        };

        // Attach DB children for this service (as leaves). Only include DB ops under this service subtree.
        const dbAgg = collectDbAggForService(span, svc);
        for (const [dbName, agg] of dbAgg.entries()) {
          const avg = calcAvg(agg.sum, agg.count);
          node.children.push({
            name: `${dbName}`,
            value: agg.count,
            itemStyle: { color: '#a57aff' },
            children: [],
            tooltip: {
              formatter: `${svc} → ${dbName}<br/>调用次数: ${agg.count}<br/>平均耗时: ${round(avg, 2)} ms`
            },
            label: { color: '#333' }
          });
        }

        // Build child service nodes by children spans
        const kids = childrenMap.get(span.id) || [];
        // group children by service to aggregate counts under same service label
        const bySvc = new Map(); // service -> {count,sum, samples: [span]}
        kids.forEach(ch => {
          const service = ch.service || 'unknown';
          if (!bySvc.has(service)) bySvc.set(service, { count: 0, sum: 0, samples: [] });
          const agg = bySvc.get(service);
          agg.count += 1;
          agg.sum += (typeof ch.duration === 'number' ? ch.duration : 0);
          agg.samples.push(ch);
        });

        for (const [childSvc, agg] of bySvc.entries()) {
          // choose one sample span of that child service to continue depth traversal
          const sample = agg.samples[0];
          const childNode = buildNode(sample);
          const avg = calcAvg(agg.sum, agg.count);
          // annotate tooltip on the relation
          childNode.tooltip = {
            formatter: `${svc} → ${childSvc}<br/>调用次数: ${agg.count}<br/>平均耗时: ${round(avg, 2)} ms`
          };
          node.children.push(childNode);
        }

        return node;
      }

      const trees = roots.map(r => buildNode(r));
      if (trees.length === 1) return trees[0];
      // multiple roots: compose a virtual root
      return {
        name: 'trace-roots',
        value: trees.length,
        itemStyle: { color: '#5c6b7a' },
        children: trees
      };
    }

    function renderTree(data, orient) {
      // Count nodes/edges for stats
      let nodeCount = 0, edgeCount = 0;
      (function dfs(n){
        if (!n) return;
        nodeCount += 1;
        const cs = n.children || [];
        edgeCount += cs.length;
        cs.forEach(dfs);
      })(data);
      document.getElementById('statNodes').textContent = `节点: ${nodeCount}`;
      document.getElementById('statEdges').textContent = `边: ${edgeCount}`;

      const option = {
        backgroundColor: '#fff',
        tooltip: { trigger: 'item' },
        series: [{
          type: 'tree',
          data: [data],
          top: '3%',
          left: orient === 'LR' ? '6%' : '10%',
          bottom: '3%',
          right: orient === 'LR' ? '20%' : '18%',
          symbol: 'circle',
          symbolSize: 10,
          orient: orient === 'LR' ? 'LR' : 'TB',
          edgeShape: 'polyline',
          edgeForkPosition: '63%',
          roam: true,
          expandAndCollapse: true,
          initialTreeDepth: 10,
          lineStyle: { color: '#97a3b4' },
          label: {
            color: '#333',
            position: orient === 'LR' ? 'left' : 'top',
            verticalAlign: 'middle',
            align: 'left',
            fontSize: 12,
            formatter: (params) => params.data && params.data.name || ''
          },
          leaves: { label: { position: orient === 'LR' ? 'right' : 'bottom', align: 'left' } },
          animationDurationUpdate: 500
        }]
      };
      chart.setOption(option);
    }

    async function init() {
      const orientSelect = document.getElementById('orientSelect');
      const showDb = document.getElementById('showDbEdges');

      const spans = await loadTrace();

      function update() {
        const tree = buildTree(spans, {
          includeDbEdges: showDb.checked,
        });
        renderTree(tree, orientSelect.value);
      }

      orientSelect.addEventListener('change', update);
      showDb.addEventListener('change', update);

      update();
    }

    init().catch(err => {
      console.error(err);
      chart.setOption({
        title: { text: '加载失败', left: 'center' },
        graphic: [{
          type: 'text', left: 'center', top: 'middle', style: {
            text: '无法加载 svc-task-executor/trace1.json\n请在该目录下启动本地静态服务器后再访问本页面。',
            fill: '#999', fontSize: 14, align: 'center'
          }}]
      });
    });

    window.addEventListener('resize', () => chart.resize());
  </script>
</body>
</html>

